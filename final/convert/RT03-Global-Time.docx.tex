\begin{enumerate}
\item ~
  \section{Chapter 3}\label{chapter-3}

  \begin{enumerate}
  \item ~
    \subsection{Global Time}\label{global-time}
  \end{enumerate}
\end{enumerate}

Overview 2

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Time and Order 3
\item
  Time Measurement 11
\item
  Dense Time versus Sparse Time 17
\item
  Internal Clock Synchronization 21
\item
  External Clock Synchronization 28
\end{enumerate}

Points to Remembe 30

\begin{enumerate}
\item ~
  \subsection{}\label{section}

  \subsection{Overview}\label{overview}
\end{enumerate}

\begin{itemize}
\item
  Notions of causal order, temporal order, and delivery order
\item
  External observers, reference clocks, and global time base
\item
  Sparse time base to view event order in a distributed real-time system
\item
  Internal clock synchronization to compensate for drift offset.
  Influence of the communication system jitter on the precision of the
  global time base.
\item
  External time synchronization, time gateways, and the Internet network
  time protocol (NTP).
\end{itemize}

\textbf{3.1} \protect\hypertarget{teil2}{}{}\textbf{Time and Order}

Time is one of the fundamental concepts in physics. Time is an
independent variable that determines the sequence of states of a system.

To achieve consistent behavior in a distributed real-time system, all
nodes must process events in the same (temporal) order. This requires
some kind of global time base which provides globally agreed upon
timestamps for all events.

\textbf{Orders: Temporal Order}

Continuum of real time can be modeled by a directed timeline consisting
of an infinite set \{T\} of instants with the following properties:

\begin{itemize}
\item
  \{T\} is an ordered set (one instance always precedes the other, or
  vice versa, or they are simultaneous). We call the order of instants a
  temporal order.
\item
  \{T\} is a dense set (you can always find a new instance between two
  existing instances)
\end{itemize}

A section of time is called a duration. An event takes place at an
instant of time. Instants are totally ordered, events are only partially
ordered (two simultaneous events are still different, while two
simultaneous instants are equivalent). Simultaneous events can be
ordered by adding an additional attribute, e.g. the number of the node
at which event occurred.

\textbf{Orders: Causal Order}

Example: Rupture of fuel line from fuel tank to injection pump. Pressure
changes abruptly, flow changes, after some time engine stops working.
Causal order is temporal order plus something.

Example with two events e1 and e2:

e1: Somebody enters a room

e2: The telephone starts ringing

Two scenarios:

1. e2 occurs after e1

2. e1 occurs after e2

Causal order can only be established for case 2.

\textbf{Orders: Delivery Order}

Events are delivered to the different nodes in a real-time system via
the communication network. The communication system guarantees that all
nodes in the system see the sequence of events in the same order, the
delivery order. The delivery order may be different from the temporal
order, e.g. in case of prioritized messages.

\textbf{Clocks}

A clock is an objective method for measuring the progress of time.

\textbf{Clocks: Physical clock}

A physical clock is a device for measuring time. It contains a counter,
and a physical oscillation mechanism that periodically generates an
event to increase the counter. The periodic event is called the
microtick of the clock.

The duration between two consecutive microticks is called the
granularity g of the clock. The granularity leads to a digitalization
error in time measurement.

Notation: means microtick \emph{i} of clock \emph{k}.

\textbf{Clocks: Reference clock}

We assume an omniscient external observer who can observe all events of
interest. This observer possesses a unique reference clock z with
frequency . This clock is in perfect agreement with the international
standard of time.

We call the granularity of clock z. We assume that the frequency of the
reference clock is very high.

\emph{Clock(event)} denotes the timestamp generated by the use of a
given clock to timestamp event e. When we timestamp events with the
reference clock, z(e), this is called the absolute timestamp of event e.

The duration between two events is measured by counting microticks of
the reference clock. The granularity of clock \emph{k} is given by the
nominal number of microticks of the reference clock \emph{z} between two
microticks of this clock \emph{k}.

The temporal order of events that occur between any two consecutive
microticks of the reference clock cannot be established from their
timestamps.

\textbf{Clocks: Clock drift}

The drift of a physical clock \emph{k} is determined by measuring the
duration of a granule of clock \emph{k} with the reference clock
\emph{z}, and dividing it by the nominal number of reference clock
microticks in a granule:

For a good clock, the drift is very close to one. For notational
convenience, the drift rate has been introduced:

Typical drift rates are in the range of to sec/sec or better. Every
clock has a non-zero drift rate. Thus any free-running clock leaves any
bounded relative time interval after a finite time.

Example: Patriot missile tracking system.

\textbf{Clocks: Failure mode of a clock}

Clocks exhibit two types of failures:

\begin{itemize}
\item
  Counter becomes faulty, exhibiting bad counter values
\item
  Drift rate exceeds specified limits
\end{itemize}

\includegraphics[width=6.01597in,height=2.90972in]{media/image1.png}

\textbf{Precision and Accuracy: Offset}

Offset at microtick i between two clocks j and k with the same
granularity is defined as

\textbf{Precision and Accuracy: Precision}

Given an ensemble of clocks \{1, 2, \ldots{}, n\}, the maximum offset
between any two clocks of the ensemble is called the precision of the
ensemble at microtick \emph{i}:

The maximum of over an interval of interest is called the precision of
the ensemble.

Because of the drift rate of any physical clock, the clocks in an
ensemble will drift apart if they are not resynchronized periodically
(internal synchronization).

\textbf{Precision and Accuracy: Accuracy}

The offset of clock \emph{k} with respect to reference clock \emph{z} at
microtick \emph{i} is called the .

The maximum offset over all microticks I that are of interest is called
the of clock \emph{k}.

To keep a clock within a bounded interval of the reference clock, it
must be periodically resynchronized with the reference clock (external
synchronization).

External synchronization automatically leads to internal
synchronization, but not vice versa.

\textbf{Time Standards}

For distributed real-time systems, two time bases are relevant.

\textbf{Time Standards: International Atomic Time (TAI)}

TAI defines the second as the duration of 9192631770 periods of the
radiation of a specified transition of the cesium atom 133. The
definition agrees with astronomical observations. TAI is a chronoscopic
time scale, i.e. it does not have discontinuities.

\textbf{Time Standards: Universal Time Coordinated (UTC)}

UTC is the basis for the time on the ``wall-clock''. There is a known
offset between the local wall-clock time and UTC which is defined by the
timezone and daylight savings time.

UTC introduces leap seconds once in a while, to maintain synchrony with
astronomical phenomena, like day and night. Thus, UTC is not a
chronoscopic time scale.

It was agreed that on January 1, 1958 at midnight UTC and TAI had the
same value. Since then UTC has deviated from TAI by about 30 seconds.

\textbf{Uniform Time Format (OMG Standard)}

Start of epoch: January 6, 1980 at 0:00:00 UTC. Granularity is 59,6 ns
approx 60 nanosecond, time horizon 34841 years. Similar to IEEE 1588.
Time granularity determined by precision of GPS.

\includegraphics[width=8.37431in,height=4.24167in]{media/image2.png}

\textbf{3.2} \protect\hypertarget{teil3}{}{}\textbf{Time Measurement }

In a distributed real-time system, local real-time clocks are not
tightly synchronized with the reference clock z, and thus reconstructing
order of events or measuring time intervals is not straight forward.

A weaker notion of a universal time reference is therefore being used -
the concept of global time.

\textbf{Global Time}

To establish global time, we pick a subset of the microticks of each
local clock k for the local implementation of a global notion of time,
e.g. every tenth microtick. These selected ticks we call macroticks .

\includegraphics[width=8.01528in,height=1.76597in]{media/image3.png}

Reasonableness condition for global time t: all local implementations
satisfy condition that granularity g is larger than the global precision
:

In case this reasonability condition is satisfied, global timestamps for
a single event differ by at most one tick.

This has a serious implication: we cannot reconstruct the temporal order
if timestamps differ by just one tick. Example:

\includegraphics[width=7.64444in,height=1.92847in]{media/image4.png}

Event 17: 1 by k, 2 by j

Event 42: 4 by j, 3 by k

Event 67: 6 by k, 7 by j

Event 69: 7 by j, 6 by k

Thus, event 67 is time stamped with 7 by clock j, and event 69, which
occurs later than event 67 as seen from the reference clock, is time
stamped with 6 by clock k.

We can reconstruct the temporal order if the timestamps differ by at
least two macroticks, because the sum of synchronization and
digitalization error is always less than 2 granules.

\textbf{Interval Measurement}

Interval is defined by two events: start event and terminating event.
The error measuring the duration of an interval is always less than
\emph{2g}. Thus, the true duration is bounded by:

Example for interval of 25 microticks duration:

\includegraphics[width=6.58125in,height=3.67639in]{media/image5.png}

\textbf{π/Δ-Precedence}

π/Δ-precedence means that a subset of the events that happen at about
the same time (and is thus close together within π) is separated by a
substantial interval (at least Δ) from the elements in another subset.

Example for events that are generated by nodes \emph{j}, \emph{k},
\emph{m}. Every node is to generate an event at 1, 5, 9. All events are
generated locally at the same global clock tick within a small time
interval π where . Events occurring at different ticks are at least Δ
apart.

\includegraphics[width=8.02639in,height=2.31389in]{media/image6.png}

If π is zero, then any two events occur either at the same time or are
at least a duration Δ apart.

\begin{longtable}[c]{@{}lll@{}}
\toprule
Event Set & Observed timestamps condition & Temporal order can be
established\tabularnewline
0/1g precedent & & No\tabularnewline
0/2g precedent & & No\tabularnewline
0/3g precedent & & Yes\tabularnewline
0/4g precedent & & Yes\tabularnewline
\bottomrule
\end{longtable}

To establish the temporal order of observed events, we need at least
0/3g precedence, i.e. the timestamps of two successive events is at
least 2 macroticks apart. (One of the three g is eaten up by possible
difference of two clocks on different nodes, see reasonableness
condition).

\textbf{Fundamental Limits of Time Measurement}

Four fundamental limits of time measurement in distributed real-time
systems with a reasonable global time base with granularity g:

\begin{itemize}
\item
  If a single event is observed by two nodes, there is always the
  possibility that the timestamps differ by two ticks. A one tick
  difference does not suffice to recover the temporal order of events.
\item
  If the observed duration of an interval is , the true duration is
  bounded by
\item
  The temporal order of events can be recovered from their timestamps,
  if the difference between their timestamps is equal to or greater than
  2 ticks.
\item
  The temporal order of events can always be recovered from their
  timestamps, if the event set is at least 0/3g precedent.
\end{itemize}

\textbf{3.3} \protect\hypertarget{teil4}{}{}\textbf{Dense Time versus
Sparse Time }

In case events can occur any time, we speak of a dense time base.

In case events are permitted to occur only in certain time intervals π,
we speak of a sparse time base.

In a dense time base it can be difficult to establish temporal order.

\includegraphics[width=7.26944in,height=1.92361in]{media/image7.png}

\textbf{Dense Time-Base}

Example scenario with two events e1 and e1, 2.5 granules apart. Event e2
is only observed by node k, which reports its timestamp back to nodes j
and m.

Node j: e1 observed at time 2; e2 from node k observed at time 3

Node m: e1 observed at time 1; e2 from node k observed at time 3

\includegraphics[width=6.76806in,height=2.19861in]{media/image8.png}

Node j calculates difference of one tick: events cannot be ordered

Node m calculates difference of two ticks: events can be ordered, with
e1 definitely occurred before e2. Thus we have an inconsistent view.

To arrive at a consistent view, the nodes must execute an agreement
protocol. However, such protocols come with a lot of communication and
processing overhead.

\textbf{Sparse Time-Base}

Example scenario with two clusters A and B, not synchronized, B observes
events generated in A.

We have up to one granule difference in clocks between nodes in A and B,
and we have up to one granule difference in clocks between nodes of A.
Likewise, if we generate events in A that are within one granule, they
can be time stamped by nodes within B with two ticks difference.

To establish temporal order in this scenario we therefore need at least
1g/4g precedence.

\textbf{Space-Time Lattice}

Example for a space-time lattice for 1/4g precedent event set:

\includegraphics[width=7.14583in,height=3.35972in]{media/image9.png}

At the instrumentation interface (between computer and controlled
object), events occur on a dense time base. We need some kind of
agreement protocol there, in case the controlled object is observed by
more than one computer node.

Node failures also occur on a dense time base. In a TT architecture the
recognition of failures can be restricted to a sparse time base, to
avoid an agreement protocol.

\textbf{3.4} \protect\hypertarget{teil5}{}{}\textbf{Internal Clock
Synchronization}

Purpose is to ensure that global ticks of all correct nodes occur within
specified precision , despite varying drift rates.

Each node has a local oscillator generating the microticks. A subset of
the microticks, the ticks or global time ticks, are taken to increment
the local global time counter.

\textbf{The Synchronization Condition}

Global time ticks of each node are periodically resynchronized each
resynchronization interval . Convergence function denotes offset of time
values immediately after resynchronization.

\includegraphics[width=6.63958in,height=3.07986in]{media/image10.png}

Drift offset and drift rate are related as

For convergence function , drift offset , and precision holds:

Byzantine error: ``two-faced'' clock. It displays to one node a
different time than to another node. This can obstruct synchronization.
Here each node sets its value to the average value of the ensemble.
Neither node A nor node B will correct its value.

\includegraphics[width=6.76736in,height=2.90625in]{media/image11.png}

\textbf{Central Master Synchronization}

A standard algorithm during the startphase of synchronization is the
central master algorithm. A maste node sends its time to all other
nodes, and they set their local times to the transmitted time, corrected
by the transport latency. Convergence function is determined by the
difference between fastest and slowest transmission to slave nodes of
ensemble, the latency jitter .

The precision of the central master algorithm is given by:

. That means the convergence function is .

\textbf{Fault tolerant Sync Algorithms}

Precision of the FTA:

Assume a distributed system with N nodes, each one with its own clock (
all time values are measured in seconds ). At most k out of N clocks
behave in a Byzantine manner.

A single Byzantine clock will cause the following difference in the
calculated averages at two different nodes in an ensemble of N clocks:

Ebyz = /(N-2k)

For K byzantine errors:

EByz = k / ( N -- 2 k )

The convergence function is given by:

k / ( N -- 2 k ) +

Combining the above function with the sync condition, we get the
Byzantine error factor.

\textbf{Distributed Synchronization Algorithms}

Typically three phases in distributed clock synchronization algorithms:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Each node acquires knowledge about global time counters of all other
  nodes
\item
  Each node analyzes the data, to detect errors, and executes
  convergence function to correct its local global time counter. If
  correction term exceeds specified precision of ensemble, node must
  deactivate itself.
\item
  Local time counter is adjusted by calculated correction value.
\end{enumerate}

\textbf{Reading the Global Time:} most important term affecting
precision is jitter of time messages. Jitter depends on communication
network, and at the level where synchronization takes place (application
level, kernel, hardware). A small jitter is important to achieve high
precision.

\textbf{Impossibility Result:} Maximum precision obtainable by given
latency jitter and number of nodes is related as

\textbf{The Convergence Function:}

Example showing an ensemble of 7 nodes and one tolerated Byzantine
fault. The Fault-Tolerant-Average (FTA) algorithm takes average of five
accepted time values shown.

\includegraphics[width=8.64167in,height=1.47917in]{media/image12.png}

Worst case scenario if all good clocks are at opposite ends of the
precision window, and Byzantine clock is seen at different corners by
two nodes.

\includegraphics[width=7.73403in,height=2.49722in]{media/image13.png}

\textbf{State Correction versus Rate Correction}

Calculated correction value can be applied to local time immediately
(state correction), or rate of clock can be modified such that the clock
speeds up or slows down to bring it into better agreement with rest of
ensemble (rate correction).

State correction leads to a discontinuity in the time base. If time is
set back, the same time is reached again. This can cause nasty errors.

Rate correction is therefore preferable.

3\textbf{.5} \protect\hypertarget{teil6}{}{}\textbf{External Clock
Synchronization}

External synchronization links global time of a cluster to an external
standard of time. A time server periodically broadcasts the current
reference time via a time message.

Time scale must be based on constant measure of time (usually physical
second), and must have a defined origin of time the epoch.

\includegraphics[width=6.89861in,height=3.41111in]{media/image14.png}

\textbf{Principle of Operation}

Time server periodically broadcasts time messages containing
synchronization events, and information to place the events on the TAI
scale. Synchronization is unidirectional; contrary to internal
synchronization it is not a cooperative activity among nodes.

If time server sends an incorrect message, all subordinates will behave
incorrectly. Some correction due to the inertia of time: the cluster
monitors the server. A time gateway will only accept a message from the
server if it is sufficiently close to its view of external time.

\textbf{Time Formats}

Format of the Network Time Protocol (NTP) of the internet:

\includegraphics[width=7.52500in,height=1.16458in]{media/image15.png}

Resolution is about 232 picoseconds.

NTP is not chronoscopic, since it is based on the UTC.

\textbf{Time Gateway}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  It initializes the cluster with the current external time.
\item
  It periodically adjusts the rate of the global time in the cluster to
  the external time base.
\item
  It periodically sends the current external time to the cluster to
  allow new nodes to synchronize.
\end{enumerate}

\protect\hypertarget{teil8}{}{}\textbf{Points to Remember}

\textbf{3 Phases}:

First phase: every node acquires knowledge about the state of the global
time counters in all other nodes by the exchange of the messages.

Second Phase: every node analyses the collected information to detect
errors and execute the convergence function to calculate a correction
value of a local global time counter. -\textgreater{} if analysis says,
sync condition nis not true, the node have to deactivate itself.

Third Phase: the local time counter of the node is adjusted by the
calculated correction value.

1g:

Clock j ticks, event occurs, clock k ticks.

Global time stamp for event can differ by at most 1 tick.

2g:

At most 2g, to understand the temporal order of two events between two
nodes.

3g:

Two events, and when a third node observes the events, then we need
atleast 3g.

4g:

In sparse time base, when there are two clusters.

If cluster A generates a 1/3g precedent event set, then it is possible
that two events that are generated at the same cluster-wide granule at
cluster A will be time-stamped by cluster B with time-stamps that differ
by 2 ticks. The observing cluster B should not order these events,
because they have been generated at the same cluster-wide granule.
Events that are generated by cluster A at different cluster wide
granules ( 3g part ) and therefore should be ordered by cluster B, could
also obtain timestamps that differ by 2 ticks. Cluster B cannot decide
whether or not to order events with a time stamp difference of 2 ticks.
Cluster B cannot decide whether or not to order events with a time stamp
difference of 2 ticks. To resolve this situation, cluster A must
generate a 1/4g precedent set.

Example:

Either telephone ringing or bus arriving at the same time OR

If difficult, then atleast 3g apart in order to determine the temporal
order.
